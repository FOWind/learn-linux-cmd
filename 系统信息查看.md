# 第一天：系统信息查看

使用计算机系统免不了查看各种系统信息，接下来就学习查看系统信息的一些命令。

## 查看系统硬件架构 `arch` 命令

`arch` 命令是一个非常简单的命令，没有参数，直接执行就可以查看系统的硬件架构

再 x86 的服务器执行可获得以下输出

```sh
~$ arch

x86_64
```

这个命令比较少用到，比较常用的是下面介绍的 `uname` 命令

## 查看系统信息 `uname` 命令

使用 `uname` 命令能查看内核名称，主机名称，内核版本，内核发行版本，硬件架构，操作系统信息。

常用的参数是 `-a`

```sh
~$ uname -a

Linux VM-20-16-ubuntu 5.4.0-90-generic #101-Ubuntu SMP Fri Oct 15 20:00:55 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
```

输出的内容分别是：内核名称，主机名，内核版本，内核发行版本，机器硬件架构，处理器架构，硬件平台架构，操作系统名

其他参数按照需求选择使用。

### `uname` 参数描述

|短参数|长参数|作用|
|-|-|-|
|-a|-all|按下面顺序输出所有信息，当 -p 和 -i 未知时不输出对应内容|
|-s|--kernel-name|输出内核名称|
|-n|--nodename|输出主机名称|
|-r|--kernel-release|输出内核版本|
|-v|--kernel-version|输出内核发行版本|
|-m|--machine|输入机器硬件架构|
|-p|--processor|输出处理器架构|
|-i|--hardware-platform|输出硬件平台架构|
|-o|--operation-system|输出操作系统|


## 查看系统运行时间 `uptime` 命令

使用 `uptime` 命令可以查看系统的运行时间，启动时间和负载情况。

直接使用 `uptime` 可以看到当前的时间，系统运行时间，已登录用户数量，和系统负载情况

```sh
~$ uptime

18:38:15 up 155 days, 18:01,  5 users,  load average: 0.00, 0.02, 0.02
```

使用 `-p` 参数可以将系统运行时间以周日时分的方式显示，执行命令后可以看到输出系统已运行 22 周 1 天 18 小时 1 分钟。

```sh
~$ uptime -p

up 22 weeks, 1 day, 18 hours, 1 minutes
```

使用 `-s` 参数可以查看系统启动的时间，执行命令后可以看到系统于 2022-11-20 00：36：38 启动

```sh
~$ uptime -s

2022-11-20 00:36:38
```
### `uptime` 命令参数描述

|短参数|长参数|描述|
|-|-|-|
|-p|--pretty|美化输出|
|-s|--since|使用 yyyy-mm-dd HH:MM:SS 的格式输出系统启动时间|

## 查看当前时间 `date` 命令

在 Linux 命令行界面需要查看当前时间使用的是 `date` 命令，date 命令除了用来查看当前时间外还可以用来进行时间戳的转换和时间的格式化。

当 `date` 命令后面不加任何参数时输出当前的日期和时间

```sh
~$ date

Tue Apr 25 17:39:46 CST 2023
```
需要输出 UTC 时间可以使用短参数 `-u` 或长参数 `--utc`、 `--universal`。

```sh
~$ date -u

Tue Apr 25 09:56:51 UTC 2023
```

`date` 提供了 `rfc-email`，`rfc-3339` 和 `iso-8601` 三种内置时间格式的输出

使用短参数 `-R` 或长参数 `--rfc-email` 可以输出 `rfc-email` 格式的时间

```sh
~$ date -R

Tue, 25 Apr 2023 18:00:23 +0800
```

 `iso-8601` 时间格式提供了 `date`、`hours`、`minutes`、`seconds`、`ns` 四种精度的时间输出，如果不指定的话默认以 `date` 的精度输出。

使用短参数 `-I` 或长参数 `--iso-8601` 可以以 `iso-8601` 的格式输出时间

```sh
~$ date -I

2023-04-25

# 以 seconds 的精度输出
~$ date -Iseconds

2023-04-25T18:04:32+08:00

# 以 ns 的精度输出

~$ date -Ins

2023-04-25T18:04:04,498156329+08:00
```

`rfc-3339` 时间格式提供了 `date`、`hours`、`minutes`、`seconds`、`ns` 四种精度的时间输出，没有默认提供的精度，需要手动指定

使用参数 `--rfc-3339` 可以 `rfc-3339` 的格式输出时间

```sh
# 以 date 的精度输出
~$ date --rfc-3339=date

2023-04-25

# 以 seconds 的精度输出
~$ date --rfc-3339=seconds

2023-04-25 18:12:58+08:00

# 以 ns 的精度输出
~$ date --rfc-3339=ns

2023-04-25 18:13:15.953675015+08:00

```

除了内置的标准格式外还可以自定义输出格式，自定义格式的方法如下所示

```sh
~$ date +%Y-%m-%d

2023-04-25

~$ date +%A

Tuesday
```

自定义格式提供的参数非常丰富可以查看下面的格式描述。

`date` 命令除了查看当前的时间还可以进行时间戳的转换和输入模糊时间进行转换，使用短参数 `-d` 和长参数 `--date` 可以手动输入信息进行转换

```sh
# 时间戳转换

~$ date -d @1682418350

Tue Apr 25 18:25:50 CST 2023

# 日期转换
~$ date -d
date -d 2021-11-1

Mon Nov  1 00:00:00 CST 2021
```

`date` 命令也可以接受来自文件的输入，使用短参数 `-f` 或长参数 `--file` 指定文件然后将文件每行的描述转换为准确的时间。

`date` 命令除了用来看时间和转换时间还有一个重要功能就是设置系统时间，使用短参数 `-s` 或长参数 `--set` 后接描述的时间就可以设置系统时间

```sh

# 使用时间戳设置时间
~$ date -s @1682418350

Tue Apr 25 18:25:50 CST 2023
```

### `date` 命令参数描述

|短参数|长参数|描述|
|-|-|-|
|-d|--date=STRING|输出 STRING 表示的时间|
|N/A|--debug|解释日期时间的转换过程，将错误的用法输出到标准错误输出|
|-f|--file=FILENAME|和 --date 用法类似，解析 FILENAME 文件每行表示的时间|
|-I[FMT]|--iso-8601[=FMT]|以 ISO 8601 的格式输出日期或时间，上面有例子展示使用方法|
|-R|--rfc--email|以 RFC 5322 的格式输出日期和时间|
|N/A|--rfc-3339=FMT|以 RFC 3339 的格式输出日期或事件，上面有例子展示使用方法|
|-r|--reference=FILENAME|输出 FILE 文件最后的修改时间|
|-s|--set=STRING|将时间设置为 STRING 描述的时间|
|-u|--utc,--universal|输出 UTC 时间|

### `date` 命令格式描述

|格式符|输出描述|
|-|-|
|%%|输出%字符|
|%a|输出星期几的本地化缩写 （如：Sun）|
|%A|输出星期几的本地化全称 （如：Sunday）|
|%b|输出月份的本地化缩写（如： Jan）|
|%B|输出月份的本地化全称 （如： January）|
|%c|输出本地化日期和时间（如： Thu Mar23:05:25 2005）|
|%C|输出当前世纪，和 %Y 类似, 不过只输出两个数字（如： 20）|
|%d|输出今天是当月的几号 （如： 01）|
|%D|输出日期，和 %m/%d/%y 输出一样|
|%e|输出填充空格的当月记号，和 %_d 输出一样|
|%F|输出日期，和 %Y-%m-%d 输出一样|
|%g|根据 IOS 星期的计算规则输出这星期所属的年份的后两位数字（see %G）|
|%G|根据 IOS 星期的计算规则输出这星期所属的年份（参考 %V）；一般和 %V 一起使用|
|%h|输出和 %b 一样|
|%H|输出 24 小时制的小时（00..23）|
|%I|输出 12 小时制的小时（01..12）|
|%j|输出今天是今年的第几天（001..366）|
|%k|输出有空格填充的 24 小时制的小时（ 0..23）；和 %_H 输出一样|
|%l|输出有空格填充的 12 小时制的小时（ 1..12）; 和 %_I 输出一样|
|%m|输出月份（01..12）|
|%M|输出分钟（00..59）|
|%n|输出一个换行|
|%N|输出纳秒（000000000..999999999）|
|%p|输出本地化的 AM 或者 PM； 如果不能确定会显示空白|
|%P|输出和 %p 类似，不过输出的是小写字母|
|%q|输出处于第几个嫉妒 （1..4）|
|%r|输出本地化后的十二小时制时间 （如： 11:11PM）|
|%R|输出 24 小时制的小时和分钟，和 %H:%M 输出类似|
|%s|输出从 1970-01-01 00:00:00 UTC 起的秒数|
|%S|输出当前的秒数（00..60）|
|%t|输出一个制表符|
|%T|输出时间，输出和 %H:%M:%S 一样|
|%u|输出星期几，1 表示星期一（1..7）|
|%U|输出当年的第几个星期，以星期天为一星期的第一天计算（0..53）|
|%V|输出 ISO 当年的第几个星期，以星期一为一个星期的第一天计算 （01.。53）|
|%w|输出今天是一个星期中的第几天 （0..6）； 0 表示星期天|
|%W|输出当年的第几个星期，以星期一为一星期的第一天计算（0..53）|
|%x|输出本地化的日期（如： 12/31/99）|
|%X|输出本地化的时间（如： 23:13:48）|
|%y|输出年份的后两位数字（00..99）|
|%Y|输出年份|
|%z|输出 +hhmm 表示的时区 （如： -0400）|
|%:z|输出 +hh:mm 表示的时区 （如： -04:00）|
|%::z|输出 +hh:mm:ss 表示的时区（如： -04:00:00）|
|%:::z|输出必要精度表示的时区（如： +05:30）|
|%Z|输出字母表示的时区 （如： EDT）|

默认情况下，日期时间的数字会填充零，下面的格式化标记需要放置在 '%' 后面

|标记|含义|
|-|-|
|- |（连接符） 不会对字段进行填充|
|_ |（下划线） 使用空格进行前冲|
|0 |（零） 使用零进行填充|
|^ |字段允许的情况下使用大写|
|# |字段允许的情况下使用小写 |


## 查看当前用户 `whoami` 和 `logname` 命令

要查看当前用户可以使用 `whoami` 和 `logname` 命令，这两个命令是没有参数的命令，直接运行即可

```sh
~$ whoami

ubuntu
```

```sh
~$ logname

ubuntu
```

## 列出所有已登录用户 `who` 和 `users` 命令

`who` 和 `users` 命令都可以列出当前已登录的用户，其中 `users` 命令比较简单，没有参数，只单纯输出已登录用户，`who` 命令配合参数可以展示更多的信息。

```sh
~$ users

ubuntu ubuntu ubuntu
```

`who` 命令不加参数时会输出登录用户，分配的终端，登录的时间和登录者的源地址

```sh
~$ who

ubuntu   pts/18       2023-04-25 18:42 (10.0.0.1)
```

如果想查看详细的信息可以添加 `-aH` 参数，`-a` 参数相当于 `-b -d --login -p -r -t -T -u` 组合参数， `-H` 参数会输出表头

```sh
~$ who -aH

NAME       LINE         TIME             IDLE          PID COMMENT  EXIT
           system boot  2022-11-20 00:36
LOGIN      tty1         2022-11-20 00:37              1186 id=tty1
LOGIN      ttyS0        2022-11-20 00:37              1182 id=tyS0
           run-level 5  2022-11-20 00:37
           pts/0        2022-11-20 02:50              2186 id=ts/0  term=0 exit=0
ubuntu   + pts/18       2023-04-25 18:42   .       3613666 (10.0.0.1)
           pts/19       2023-04-25 00:35           3241420 id=s/19  term=0 exit=0
           pts/20       2023-04-25 01:11           3252158 id=s/20  term=0 exit=0
           pts/21       2023-04-24 18:42           3132582 id=s/21  term=0 exit=0
           pts/22       2023-04-24 19:53           3153975 id=s/22  term=0 exit=0
           pts/23       2023-04-24 20:19           3161762 id=s/23  term=0 exit=0
```

### `who` 命令参数描述

|短参数|长参数|描述|
|-|-|-|
|-a|-all|和 -b -d --login -p -r -t -T -u 组合输出一样|
|-b|--boot|系统最新启动时间|
|-d|--dead|输出死亡进程|
|-H|--heading|输出表头|
|N/A|--ips|输出 ip 地址而不是输出主机名。配合 --lookup 使用会将输出的主机名转化为 IP 地址|
|-l|--login|输出系统登录进程|
|N/A|--lookup|尝试通过 DNS 解析主机名|
|-m|N/A|只查看占用当前标准输出的用户和主机名信息|
|-p|--process|输出 init 派生出的进程|
|-r|--runlevel|输出当前的运行等级|
|-s|--short|只输出用户名，分配的终端和登录时间（默认参数）|
|-t|--time|输出最后一次系统时钟更改|
|-T -w|--mesg|增加用户的消息状态（+、-或 ?）|
|-u|--users|列出已登录用户|
|N/A|--message|和 -T 类似|
|N/A|--writable|和 -T 类似|


## 查看用户所在组 `groups` 命令

`groups` 命令可以查看用户所在的组，命令的作用是查看输入的用户所属的用户组，当没有输入用户时功能为查看当前用户所在的用户组。

```sh
~$ groups

ubuntu adm cdrom sudo dip plugdev lxd
```

当输入多个用户时会依次输出各个用户所属的用户组

```sh
~$ groups ubuntu root

ubuntu : ubuntu adm cdrom sudo dip plugdev lxd
root : root
```

## 查看系统用户和用户组 `id` 命令

`id` 命令可以用来查看特定用户和用户组的 ID。 直接执行查看的时当前用户和所属用户组的名称和 ID。

```sh
~$ id

uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)
```

当只需要查看用户 ID 时可以使用短参数 `-u` 或者长参数 `--user`

```sh
~$ id -u

1000
```

需要查看所属用户组 ID 时可以使用短参数 `-G` 或者长参数 `--groups`

```sh
~$ id -G

1000 4 24 27 30 46 116
```

当为命令提供一个用户名时则为查看其用户和所属用户组的名称和 ID。

```sh
~$ id root

uid=0(root) gid=0(root) groups=0(root)
```

### `id` 命令参数描述

|短参数|长参数|描述|
|-|-|-|
|-a|N/A|没有作用，只用于兼容其他版本|
|-Z|--context|输出当前进程的安全上下文|
|-g|--group|仅输出生效 ID|
|-G|--groups|输出所有用户组 ID|
|-n|--name|输出名字而不是 ID 值，配合 -ugG 使用|
|-r|--real|输出实际 ID 而不是生效 ID，可以配合 -ugG 使用|
|-u|--user|只输出当前用户 ID|
|-z|--zero|使用 NUL 字符而不是空格分割元素，不能用来修改默认格式|

## 查看系统环境便令 `printenv` 命令

查看所有环境变量在 Linux 系统中一般会使用 `env` 命令，但 `env` 命令还有其他的用处，`printenv` 是比较纯粹的查看所有系统环境变量的命令。`printenv` 只有一个参数，短参数 `-0`、长参数 `--null` 用于改变输出的格式。

不使用参数时为一个变量一行的格式输出

```sh
~$ printenv

SHELL=/bin/bash
HISTSIZE=1000
LANGUAGE=en_US.utf8:
HISTTIMEFORMAT=%F %T
PWD=/home/ubuntu
LOGNAME=ubuntu
XDG_SESSION_TYPE=tty
MOTD_SHOWN=pam
HOME=/home/ubuntu
LANG=en_US.utf8
```

使用参数时会直接合并输出

```sh
~$ printenv -0

SHELL=/bin/bashHISTSIZE=1000LANGUAGE=en_US.utf8:HISTTIMEFORMAT=%F %T PWD=/home/ubuntuLOGNAME=ubuntuXDG_SESSION_TYPE=ttyMOTD_SHOWN=pamHOME=/home/ubuntuLANG=en_US.utf8
```

使用参数后输出并不美观，也不好处理，所以默认直接使用 `printenv`  即可。
